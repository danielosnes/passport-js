
Review your answers
1.
The following code is attempting to set up Passport’s local strategy.

Fill in the blanks in the following code. In which order do we need to implement the proper checks and return the proper values?

Your correct answer
passport.use(new LocalStrategy(
  function (username, password, done) {
    // Look up user in the db
    db.users.findByUsername(username, (err, user) => {
      
      
if(err) return done(err);


      
if(!user) return done(null, false);


      
if(user.password != password) return done(null, false);


      
return done(null, user);

    });
  })
);
2.
The following code is attempting to register a user using passport-local.

Fill in the blanks with the correct arguments.

Your correct answer
app.post("/register", async (req, res) => {
  const { username, password } = req.body;
  const newUser = await db.users.createUser({ username, password });
  if (
newUser
) {
    res.status(
201
).json({
      msg: "Insert Success Message Here",
      newUser
    });
  } else {
    res.status(
500
).json({ msg: "Insert Failure Message Here" });
  }
}
3.
What is the definition of Hashing?

Your correct answer
Hashing is a one-way process that takes data of any size and represents it as a unique hash value of a fixed size.

4.
The following code is using bcrypt.js to secure a password.

Fill in the following arguments.

Your correct answer
const passwordHash = async (password, saltRounds) => {
  try {
    const salt = await bcrypt.genSalt(
saltRounds
);
    return await bcrypt.hash(
password, salt
);
  } catch (err) {
    console.log(
err
);
  }
  return null;
};
5.
Fill in the blanks to create a true statement about Rainbow Tables and Salts.

Your correct answer
A 
rainbow table
 is a massive table of common passwords and password-
hash
 combinations used by attackers to break into accounts. One common technique we can take to protect ourselves from 
rainbow table
 attacks is the use of 
salt
s.
6.
The following code is attempting to log in a user and redirect them to their profile using passport-local.

Fill in the blanks with the correct arguments.

Your answer
app.post("/login",
  passport.authenticate(
"local"
, { failureRedirect : 
"/login"
}),
  (req, res) => {
    res.redirect(
"/profile"
);
  }
);

app.get("/profile", (req, res) => {
  res.render("profile", { user: req.user });
}); 
Correct answer
app.post("/login",
  passport.authenticate(
"local"
, { failureRedirect : 
"/login"
}),
  (req, res) => {
    res.redirect(
"profile"
);
  }
);

app.get("/profile", (req, res) => {
  res.render("profile", { user: req.user });
}); 
In the provided code snippet, the first blank is correctly filled with “local” to indicate that the “passport-local” strategy is being used for authentication. The second blank should be “/login” to specify that, upon failure to authenticate, the user should be redirected back to the login page. Lastly, the third blank must be “profile” to direct the user to their profile page after successful login, where the endpoint for rendering the profile page is actually “/profile”.



Powered by OpenAI
 
7.
The following code is attempting to serialize and deserialize a user using passport-local.

Fill in the blanks with the correct parameters.

Your correct answer
passport.serializeUser((
user, done
) => {
  done(null, user.id);
});

passport.deserializeUser((
id, done
) => {
  db.users.findById(id, function (
err, user
) {
    if (err) return done(err); 
    done(null, user);
  });
});
8.
The following code is attempting to log out a user using passport-local.

Fill in the proper function calls.

Your correct answer
app.
get
("/logout", (req, res) => {
  req.
logout
();
  res.
redirect
("/login");
});
9.
The following code is attempting to log out a user using passport-local.

Put the following lines of code in the correct order.

Your correct answer
app.get("/logout", (req, res) => {
  
req.logout();

  
res.redirect("/login");

});
10.
The following code is using bcrypt.js to verify a password against a stored password hash.

Fill in the missing lines of code.

Your correct answer
const comparePasswords = async (password, hash) => {
  try {
    
const matchFound = await bcrypt.compare(password, hash);

    
return matchFound;

  } catch (err) {
    
console.log(err);

  }
  
return false;

};
11.
The following code is attempting to log in a user and redirect them to their profile using passport-local.

Fill in the blanks in the following code.

Your correct answer
app.post
("/login",
  passport.authenticate("local", { failureRedirect : "/login"}),
  (req, res) => {
    
res.redirect
("profile");
  }
);

app.get
("/profile", (req, res) => {
  
res.render
("profile", { user: req.user });
}); 
12.
The following code is attempting to serialize and deserialize a user using passport-local.

Fill in the blanks in the following code.

Your correct answer
passport.
serializeUser
((user, done) => {
  
done(null, user.id);

});

passport.
deserializeUser
((id, done) => {
  db.users.findById(id, function (err, user) {
    if (err) return 
done(err);

    
done(null, user);

  });
});
13.
The following code is attempting to set up Passport’s local strategy.

Fill in the blanks with the correct arguments. Look at the comments in the code for clues as to how to fill in the arguments.

Your answer
passport.use(new LocalStrategy(
  function (username, password, done) {
    // Look up user in the db
    db.users.findByUsername(username, (err, user) => {
      // There was an error in the database lookup
      if(err) return done(
err, false
);

      // A user was NOT found and there was NO error
      if(!user) return done(
null, false
);

      // A user was found, but the password was NOT valid
      if(user.password != password) return done(
null, false
);

      // There was no error, the user and password are valid
      return done(
null, user
)
    });
  })
);
Correct answer
passport.use(new LocalStrategy(
  function (username, password, done) {
    // Look up user in the db
    db.users.findByUsername(username, (err, user) => {
      // There was an error in the database lookup
      if(err) return done(
err
);

      // A user was NOT found and there was NO error
      if(!user) return done(
null, false
);

      // A user was found, but the password was NOT valid
      if(user.password != password) return done(
null, false
);

      // There was no error, the user and password are valid
      return done(
null, user
)
    });
  })
);
To effectively handle errors in the Passport local strategy, the first argument to the done function when an error occurs should be the error object itself (i.e., err), while the second argument should be null to signify that there is no valid user to return. For user authentication failures, returning false as the second argument in the appropriate conditions indicates that login was unsuccessful, whereas successfully matching the username and password pairs returns the user object as the second argument. This structure effectively informs Passport of the authentication state.



Powered by OpenAI
 
14.
The following code is attempting to register a user using passport-local.

Fill in the blanks in the following code.

Your answer
app.post
("/register", async (req, res) => {
  const { username, password } = req.body;
  const newUser = await 
db.users.createUser
({ username, password });
  if (newUser) {
    
res.status(201).json
({
      msg: "Insert Success Message Here",
      newUser
    });
  } else {
    
res.status(403).json
({ msg: "Insert Failure Message Here" });
  }
}
Correct answer
app.post
("/register", async (req, res) => {
  const { username, password } = req.body;
  const newUser = await 
db.users.createUser
({ username, password });
  if (newUser) {
    
res.status(201).json
({
      msg: "Insert Success Message Here",
      newUser
    });
  } else {
    
res.status(500).json
({ msg: "Insert Failure Message Here" });
  }
}
To register a user successfully, the first blank should use app.post to define an HTTP POST endpoint for user registration. The last part of the code should return a status code indicating a server error if user creation fails, which is why res.status(500).json is the correct choice for the fourth blank, as it properly handles server-side errors.



Powered by OpenAI
